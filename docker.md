# Docker Container for Undetectable Scraping

This document outlines the strategy for running the shot-power-scraper application within a Docker container designed to be as undetectable as possible.

## Approach

The primary goal is to create a containerized environment that closely mimics a standard, non-virtualized desktop machine, thereby avoiding common red flags used for bot detection.

Key decisions in the `Dockerfile`:

1.  **Base Image**: We use `mcr.microsoft.com/playwright/python:v1.45.0-jammy` instead of a minimal Alpine image. This Debian-based image comes pre-configured with a comprehensive set of browser dependencies, libraries, and system configurations that are essential for running a browser in a "normal" environment. This helps prevent fingerprinting based on missing libraries or unusual system setups.

2.  **Non-Root User**: The container creates and runs the application as a non-root user (`appuser`). Running as root is a common sign of a containerized or automated environment.

3.  **Expanded Font Installation**: To further blend in, the Dockerfile installs a wide array of common fonts, including Microsoft Core Fonts (`ttf-mscorefonts-installer`) and Google Noto fonts. Websites can easily detect the set of installed fonts, and a minimal set is a strong indicator of a headless or server environment.

4.  **Dependency Management**: The application's Python dependencies are installed into a virtual environment (`.venv`) using `uv` and the `uv.lock` file. This ensures reproducible builds and isolates the application's dependencies from the system's Python environment.

## How to Use

Follow these steps to build the Docker image and run the scraper.

### 1. Build the Image

From the project's root directory, run the following command. This will build the image and tag it with the name `shot-power-scraper`.

```bash
docker build -t shot-power-scraper .
```

### 2. Run the Container

The container is configured to run the `main.py` script directly. You can pass any arguments to the scraper just as you would on the command line.

**Example:** Take a screenshot of `https://bot.sannysoft.com` and save it to a local `output` directory.

```bash
# Create the output directory on your host machine first
mkdir -p output

# Run the container
docker run --rm -it --shm-size=2g \
  -v $(pwd)/output:/home/appuser/app/output \
  shot-power-scraper \
  screenshot https://bot.sannysoft.com -o output/bot_sannysoft.png
```

### Explanation of `docker run` flags:

-   `--rm`: Automatically removes the container when it exits, keeping your system clean.
-   `-it`: Runs the container in interactive mode and allocates a pseudo-TTY, which is good practice for CLI applications.
-   `--shm-size=2g`: Allocates 2GB of shared memory. Modern browsers make heavy use of shared memory, and the default Docker limit is often too low, leading to browser crashes on complex websites.
-   `-v $(pwd)/output:/home/appuser/app/output`: Mounts the `output` directory from your current working directory on the host into the `/home/appuser/app/output` directory inside the container. This is how you persist files (like screenshots) generated by the scraper.

## Further Stealth Considerations

While this Docker setup provides a strong environmental foundation for stealth, the most critical factor is the IP address. Running this container from a known datacenter IP address (like those used by AWS, Google Cloud, etc.) is a major red flag.

For serious scraping, you should route the container's traffic through a **high-quality residential or mobile proxy service**.

```